# 高并发内容：

架构图：

![high-concurrency-system-design](https://github.com/doocs/advanced-java/raw/master/images/high-concurrency-system-design.png)

## 系统拆分：

将系统拆分为多个子系统，使用dubbo+zookeeper或者是Eureka来搞，一个系统连接一个数据库。使用微服务的架构



## 缓存：

大部分高并发为：读多写少

因此将数据在数据库和缓存均写一份。读的时候尽量走缓存（redis单机可以承受几万的并发）。



## MQ

使用MQ进行异步。进行数据库削峰，避免一个业务操作在数据库里进行几十次。将请求灌入MQ，系统消费异步进行写。MQ可以抗几万的并发

## 分库分表

一个数据库拆为多个库，多个库抗高并发

**分库分表的方式**：

- 一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如**时间范围**来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。
- 或者是按照某个字段 hash 一下均匀分散，这个较为常用。

### 为什么

**支撑高并发、数据量大**

### 分表

单表数据量太大(单表到达几百万)，影响到sql执行的性能。分表就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

### 分库

一个库一般按照最多撑到并发2000，你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。

### 水平拆分

**水平拆分**的意思，就是把**一个表的数据**给弄到**多个库的多个表**里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。

### 垂直拆分：

**垂直拆分**的意思，就是**把一个有很多字段的表给拆分成多个表**，**或者是多个库上去**。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会**将较少的访问频率很高的字段放到一个表里去**，然后**将较多的访问频率很低的字段放到另外一个表里去**。

### 表层面的拆分

就是分表，将一个表变成 N 个表，就是**让每个表的数据量控制在一定范围内**，保证 SQL 的性能。否则单表数据量越大，SQL 性能就越差。一般是 200 万行左右，不要太多，但是也得看具体你怎么操作，也可能是 500 万，或者是 100 万。你的SQL越复杂，就最好让单表行数越少。

​	

​	一般来说，垂直拆分，你可以在表层面来做，对一些字段特别多的表做一下拆分；水平拆分，你可以说是并发承载不了，或者是数据量太大，容量承载不了，你给拆了，按什么字段来拆，你自己想好；分表，你考虑一下，你如果哪怕是拆到每个库里去，并发和容量都 ok 了，但是每个库的表还是太大了，那么你就分表，将这个表分开，保证每个表的数据量并不是很大。



## 读写分离

大部分数据库是读多写少，将请求分散开。

从主库进行写入，从库进行读取。

当读的流量过多的时候，增加新的从库



### 主从复制原理：

- 主库将变更写入binlog日志，从库连接到主库之后，从库有IO线程，将主库的binlog日志拷贝到自己本地，写入一个relay中继日志中。

- 从库有一个SQL线程从中继日志中读取binlog日志，然后执行binlog日志的内容。（也就是在本地再执行一次sql语句）
- 



## Elasticsearch

使用es来进行一些比较简单的查询、统计类的操作








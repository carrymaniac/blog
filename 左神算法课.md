

布隆过滤器

m比特数值，即数组空间大小

m=-(n*lnP)/(ln2)^2

K值和预期失误率有关

K=ln2*(m/n)=0.7*(m/n)

其中n为样本量，P是预期失误率

当M和K确定向上取整之后，真正的失误率为：

(1-e^(-n*k/m))^k





一致性哈希：

经典的服务器设计：前端或者是中间件通过hash函数将数据放在某个服务器

缺点：无法解决加机器减机器的需求



一致性哈希结构：即哈希环，先进行哈希函数获得一个哈希值，然后再哈希环上顺时针找到一个距离这个哈希值最近的服务器节点

此时添加、删除新的服务器节点，数据迁移的代价相当低。

实际使用方式:将所有的服务器的hash值按大小存放在数组，然后新的数据过来之后使用二分方式找到一个离他最近的服务器节点。

使用虚拟节点：避免节点过少时数据不均分、产生倾斜。





# 并查集
- 查询两个元素是否属于同一集合
- 合并两个元素所在的集合

并查集只能在初始化的时候固定好元素 不能使用流

## 并查集重要结构
普通的list和set无法做到快速合并和查找

有一个代表节点，代表了整个集合，每个集合中的节点不断往上指。最后到达代表节点

每次查询某节点的代表节点时，则会将节点直接挂在代表节点上（扁平化）



### 广度优先遍历(按层)

​	广度优先搜索一层一层地进行遍历，每层遍历都以上一层遍历的结果作为起点，遍历一个距离能访问到的所有节点。需要注意的是，遍历过的节点不能再次被遍历。

​	每一层遍历的节点都与根节点距离相同。设 di 表示第 i 个节点与根节点的距离，推导出一个结论：对于先遍历的节点 i 与后遍历的节点 j，有 di <= dj。利用这个结论，可以求解最短路径等 **最优解** 问题：第一次遍历到目的节点，其所经过的路径为最短路径。应该注意的是，使用 BFS 只能求解无权图的最短路径，无权图是指从一个节点到另一个节点的代价都记为 1。

​	在程序实现 BFS 时需要考虑以下问题：

- 队列：用来存储每一轮遍历得到的节点；
- 标记：对于遍历过的节点，应该将它标记，防止重复遍历。







递归中可以使用stack（或者是其他结构）来存储你需要的数据结构，以便于之后再次使用。



## 图

图的表示：邻接矩阵和邻接表法


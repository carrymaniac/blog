## 观察者模式

当有多个观察者想同时观察同一个主题对象的时候，当主题对象的 状态发生变化，观察者能够回调自身的方法去更新自己

>  被观察者接口

```java
public interface Subject{
  /**
     * 添加观察者
     * @param observer
     */
    void addObserver(Observer observer);
    /**
     * 移除指定的观察者
     * @param observer
     */
    void removeObserver(Observer observer);
    /**
     * 移除所有的观察者
     */
    void removeAll();

    /**
     * data 是要通知给观察者的数据
     * 因为Object是所有类的父类，可以使用多态，当然 你也可以使用 泛型
     * @param data
     */
    void notifyAllObserver(Object data);

    /**
     * 单独 通知某一个观察者
     * @param observer
     * @param data
     *  data 是要通知给观察者的数据
     * 因为Object是所有类的父类，可以使用多态，当然 你也可以使用 泛型
     */
    void notify(Observer observer,Object data);
}
```

> 观察者接口

```java
/**
 * 观察者接口
 * @author Administrator
 *
 */
public interface Observer {

    /**
     * 
     * @param subject 被观察者
     * @param data    被观察者传递给观察者的 数据
     */
    void update(Subject subject,Object data);
}
```

> 实现的被观察者

```java
public class ConcreteSubject implements Subject {

    List<Observer> mList = new ArrayList<>();

    @Override
    public void addObserver(Observer observer) {
        if (observer == null) {
            throw new NullPointerException("observer == null");
        }
		// 确保相同的观察者只含有一个
        if (!mList.contains(observer)) {
            mList.add(observer);
        }
      
    }

    @Override
    public void removeObserver(Observer observer) {
        mList.remove(observer);

    }

    @Override
    public void removeAll() {
       mList.clear();
    }



    @Override
    public void notifyAllObserver(Object data) {
        for (Observer observer : mList) {
            observer.update(this,data);
        }

    }

    @Override
    public void notify(Observer observer, Object data) {
        if(observer!=null){
          //调用其update方法
            observer.update(this, data);
        }

    }

}
```

> 观察者

```java
public class NBAObserver implements Observer {

    @Override
    public void update(Subject subject, Object data) {
        System.out.println( " 我是"+this.getClass().
                getSimpleName()+"，  "+data+"别看NBA了");

    }

}
```





## 优缺点

优点：解耦了通知者（被观察者）和观察者，观察者不需要知道通知者内部怎么实现的，方便日后代码的修改

缺点：

- 抽象通知者和抽象观察者依旧发生了依赖
- 要求观察者的所有动作 必须一样 ，如果不一样的话，不能实现

## 事件委托



> 通知者 这里的通知者只需要实现方法，具体观察者该进行什么操作使用反射进行

```java
/**
 * 通知者的 抽象类
 * @author xujun
 *
 */
public abstract class Notifier {
    private EventHandler eventHandler = new EventHandler();

    public EventHandler getEventHandler() {
        return eventHandler;
    }

    public void setEventHandler(EventHandler eventHandler) {
        this.eventHandler = eventHandler;
    }

    /**
     * 增加需要帮忙 放哨 的 学生
     * 
     * @param object 要执行方法的对象
     * @param methodName 执行方法 的方法名
     * @param args   执行方法的参数
     */
    public abstract void addListener(Object object, String methodName,
            Object... args);

    /**
     * 告诉所有要帮忙放哨的学生：老师来了
     */
    public abstract void notifyX();

```

> 通知类的实现

```java
public class GoodNotifier extends Notifier {   

    @Override  
    public void addListener(Object object, String methodName, Object... args) {   
        System.out.println("有新的同学委托尽职尽责的放哨人!");   
        EventHandler handler = this.getEventHandler();
        handler.addEvent(object, methodName, args);   
    }   

    @Override  
    public void notifyX() {   
        System.out.println("尽职尽责的放哨人告诉所有需要帮忙的同学：老师来了");   
        try{   
          	//调用的是Handler里的方法进行通知
            this.getEventHandler().notifyX();   
        }catch(Exception e){   
            e.printStackTrace();   
        }   
    }   

}   
```

> 事件类

```java
public class Event {   
    //要执行方法的对象   
    private Object object;   
    //要执行的方法名称   
    private String methodName;   
    //要执行方法的参数   
    private Object[] params;   
    //要执行方法的参数类型   
    private Class[] paramTypes;   

    public Event(){   

    }   

    public Event(Object object,String methodName,Object...args){   
        this.object=object;   
        this.methodName=methodName;   
        this.params=args;   
        contractParamTypes(this.params);   
    }   
    //根据参数数组生成参数类型数组   
    private void contractParamTypes(Object[] params){   
        this.paramTypes=new Class[params.length];   
        for(int i=0;i<params.length;i++){   
            this.paramTypes[i]=params[i].getClass();   
        }   
    }   


    public Object getObject() {
        return object;
    }

  //这里省略了若干get和set方法

    /**
     * 根据该对象的方法名，方法参数，利用反射机制，执行该方法  
     * @throws Exception
     */
    public void invoke() throws Exception{   
      	//利用方式实现方法，参数为方法名，方法参数类型
        Method method=object.getClass().getMethod(this.getMethodName(),
                         this.getParamTypes());   
        if(null==method){   
            return;   
        }   
      	//使用反射进行方法调用
        method.invoke(this.getObject(), this.getParams());   
    }   
}
```

接下来的基本上很简单了

> 事件处理

```java
public class EventHandler {   
    //是用一个List   
    private List<Event> objects;   

    public EventHandler(){   
        objects=new ArrayList<Event>();   
    }   
    //添加某个对象要执行的事件，及需要的参数   
    public void addEvent(Object object,String methodName,Object...args){   
        objects.add(new Event(object,methodName,args));   
    }   
    //通知所有的对象执行指定的事件   
    public void notifyX() throws Exception{   
        for(Event e : objects){   
            e.invoke();   
        }   
    }   
} 
```







### 优点

通知者类完全不知道自己需要通知的是谁，做到了完全解耦

同时也去掉了抽象的观察者类

观察者模式的缺点是抽象通知者依赖抽象观察者，.NET中用委托技术处理这个问题，事件委托扩展性好





**重点区分它和代理模式的区别**

代理模式如下：

```java
// 抽象角色：
abstract class Subject {
    abstract public void request();
}
// 真实角色：实现了Subject的request()方法
class RealSubject extends Subject {
    public RealSubject() {}
    public void request() {
        System.out.println(" From real subject. ");
    }
}
// 代理角色：
class ProxySubject extends Subject {
    // 以真实角色作为代理角色的属性
    private Subject realSubject;
    public ProxySubject(Subject realSubject) {
        this.realSubject = realSubject;
    }
    // 该方法封装了真实对象的request方法
    public void request() {
        //preRequest();
        System.out.println("代理准备...");
        // 此处执行真实对象的request方法
        realSubject.request();
        //postRequest();
        System.out.println("代理结束...");
    }
}
public class Client {
    public static void main(String[] args) {
        RealSubject real = new RealSubject();
        Subject sub = new  ProxySubject(real);
        sub.request();
    }
}
```

而事件委托更多的情况下，应该是一个平级的关系。





## state设计模式

将继承关系转变为组合关系。


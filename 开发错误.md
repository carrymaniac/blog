[TOC]



### 数据库：Cannot add foreign key constraint

三种情况：

（1）外键对应的字段数据类型不一致（包括数据精度、字符集和排序规则）

（2）设置外键时“删除时”设置为“SET NULL”

（3）两张表的存储引擎不一致



#### git commit 不输入 -m 以及后面的内容会进入vim模式

##### vi & vim 有两种工作模式：

- （1） 命令模式：接受、执行 vi & vim 操作命令的模式，打开文件后的默认模式；
- （2） 编辑模式：对打开的文件内容进行 增、删、改 操作的模式； 在编辑模式下按下 ESC 键，回退到命令模式。

##### 创建、打开文件：$ vi [filename]

- （1）使用 vi 加 文件路径（或文件名）的模式打开文件，如果文件存在则打开现有文件，如果文件不存在则新建文件，并在终端最下面一行显示打开的是一个新文件。
- （2）键盘输入字母 “i”或“Insert”键进入最常用的插入编辑模式。

##### 保存文件：

- （1）在插入编辑模式下编辑文件。
- （2）按下 “ESC” 键，退出编辑模式，切换到命令模式。
- （3）在命令模式下键入"ZZ"或者":wq"保存修改并且退出 vi 。
- （4）如果只想保存文件，则键入":w"，回车后底行会提示写入操作结果，并保持停留在命令模式。

##### 放弃所有文件修改：

- （1）放弃所有文件修改：按下 "ESC" 键进入命令模式，键入 ":q!" 回车后放弃修改并退出vi。
- （2）放弃所有文件修改，但不退出 vi ，即回退到文件打开后最后一次保存操作的状态，继续进行文件操作：按下 "ESC" 键进入命令模式，键入 ":e!" ，回车后回到命令模式。



### 新建一个testUser表

包含字段如下：

user_id:int 编号自动增长的主键。
user_name: varchar(12) 用户名。
real_name: varchar(12) 姓名。
password: varchar(8) 密码。
sex: int 性别，只能是0或1.
degree: int 学历，只能是1,2,3或者4.
birthday: datetime 生日。

```sql
CREATE TABLE `testuser` (
  `user_id` int(11) NOT NULL auto_increment,
  `user_name` varchar(12) NOT NULL default '',
  `real_name` varchar(12) NOT NULL default '',
  `password` varchar(8) NOT NULL default '',
  `sex` enum('0','1') NOT NULL default '0',
  `degree` enum('1','2','3','4') NOT NULL default '1',
  `birthday` datetime default NULL,
  PRIMARY KEY  (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
```

### 如何设计一个日期

java简单类中设计日期要使用long类型

因为在数据库中使用Timestamp类型

而在java中使用的是java.util.date

此时需要使用long类型进行中间桥梁

###  JFrame

swing开发中可以考虑使用html代码格式进行字体的规范化输出。

### 大文件上传问题

- 传输文件过大导致带宽资源紧张，请求速度降低；
- 文件过大导致后端程序卡死，请求无响应；
- 由于请求无法及时响应，导致前端页面卡顿，用户体验下降；
- 甚至导致已经成功上传但是请求响应错误以致于用户进行重复上传的问题；
- 服务器资源紧张，使服务器压力增大。

使用分片上传

- 多图上传是单图上传的升级版，本质上就是多次的单图上传处理；
- 而大文件上传处理是多文件上传的升级版，本质上就是将大文件切分成多个小文件并实现多文件上传；
- 断点续传则是大文件上传的升级版，多了一层分片是否已存在的验证逻辑。



## 分页操作

### TIP

分页信息区的设计和展示如上图所示，前端分页区比较重要的几个信息包括：

- 总页数
- 页码展示
- 当前页码
- 每页条数

### 前端

使用

### 后台

后台应该对前端传过来的请求对分页所需数据进行正确的查询并且返回,两端的侧重点并不相同，比如前端需要展示所有页码，而后端则只需要提供总页数即可，并不需要对这个总页码进行其他操作，比如前端需要根据用户操作记录当前页码这个参数以便对页码信息进行调整和限制，而后端并不是关注当前页码，只需要接收前端传输过来的页码进行相应的判断和查询操作即可。

后台必不可少的两个参数为

- 页码(需要第几页的数据)
- 每页的条数(每次查询多少条数据)

因此数据库查询语句为:

```sql
select * from tb_xxxx limit 10,20
```

通过页码和条数确定数据库需要查询的是从第几条到第几条的数据，比如查询第1页，每页20条数据，就是查询数据库中从0到20条数据，查询第4页，每页10条数据，就是查询数据库中第30到40条数据，因此对于后端来说页码和条数两个参数就显得特别重要，缺少这两个参数根本无法继续之后的查询逻辑，分页数据也就无从查起。



此外,后台还需要将数据总量或者是数据总页数返回给前端,数据总量不可少,而总页数可以通过总量除以每页条数.

总量查询方法为:

```sql
select count(*) from tb_xxxx
```

之后封装返回给前端

##### 关于封装

```java
//这是个分页结果集合
public class PageResult implements Serializable {
    //总记录数
    private int totalCount;
    //每页记录数
    private int pageSize;
    private int totalPage;
    private int currPage;
    private List<?> list;

    /**
     * 分页
     * @param list 列表数据
     * @param totalCount 总记录数
     * @param pageSize 每页记录数
     * @param currPage 当前页数
     */
    public PageResult(List<?> list,int totalCount , int pageSize ,int currPage){
        this.totalCount = totalCount ;
        this.pageSize = pageSize;
        this.currPage = currPage ;
        this.list = list;
        this.totalPage = (int)Math.ceil((double)totalCount/pageSize);
    }

    public int getTotalCount() {
        return totalCount;
    }

    public void setTotalCount(int totalCount) {
        this.totalCount = totalCount;
    }

    public int getPageSize() {
        return pageSize;
    }

    public void setPageSize(int pageSize) {
        this.pageSize = pageSize;
    }

    public int getTotalPage() {
        return totalPage;
    }

    public void setTotalPage(int totalPage) {
        this.totalPage = totalPage;
    }

    public int getCurrPage() {
        return currPage;
    }

    public void setCurrPage(int currPage) {
        this.currPage = currPage;
    }

    public List<?> getList() {
        return list;
    }

    public void setList(List<?> list) {
        this.list = list;
    }
}

```



```java
//这是一个分页参数集合,通过该类来放置前端传来的参数
public class PageUtil extends LinkedHashMap<String,Object> {
    private int page;//当前页码

    private int limit;

    public PageUtil(Map<String,Object> params){
        this.putAll(params);

        //分页参数
        this.page = Integer.parseInt(params.get("page").toString());
        this.limit = Integer.parseInt(params.get("limit").toString());
        this.put("start",(page-1)*limit);
        this.put("page",page);
        this.put("limit",limit);
    }

    public int getPage() {
        return page;
    }

    public void setPage(int page) {
        this.page = page;
    }

    public int getLimit() {
        return limit;
    }

    public void setLimit(int limit) {
        this.limit = limit;
    }
}

```



## Mybatis

- mapper文件需要写好xml文件头,否者会导致绑定失败
- mapper文件中的mapper标签记得写好namespace

## 分页操作流程

1. 前端将页码和条数两个参数通过 HTTP 请求传输给后端；
2. 后端获取到这两个参数后进行参数验证，查询后将当前页的所有数据实体和数据总量封装；
3. 后端将封装数据返回给前端；
4. 前端获取到数据和数据量后分别进行当前页数据进行渲染和展示，同时完成分页信息区的计算和展示。



### HTTP状态码

- 200 

成功

- 500 Internal Server Error

服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。



### Spring

#### @RequestBody和@RequestParam区别

RequestParam接受的参数来自与requestHeader（请求头），也就是URL中

RequestBody注解接收的参数则是来自于requestBody中，即请求体中。

@RequestParam 

A） 常用来处理简单类型的绑定，通过 Request.getParameter() 获取的String可直接转换为简单类型的情况（ String--> 简单类型的转换操作由ConversionService配置的转换器来完成）；因为使用request.getParameter()方式获取参数，所 以可以处理get 方式中queryString的值，也可以处理post方式中 body data的值；

B）用来处理Content-Type: 为 `application/x-www-form-urlencoded`编码的内容，提交方式GET、POST；

C) 该注解有两个属性： value、required； value用来指定要传入值的id名称，required用来指示参数是否必须绑定；



@RequestBody

该注解常用来处理Content-Type: 不是`application/x-www-form-urlencoded`编码的内容，例如application/json, application/xml等；

它是通过使用HandlerAdapter 配置的`HttpMessageConverters`来解析post data body，然后绑定到相应的bean上的。

因为配置有FormHttpMessageConverter，所以也可以用来处理 `application/x-www-form-urlencoded`的内容，处理完的结果放在一个MultiValueMap<String, String>里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api;





      由于项目是前后端分离，因此后台使用的是spring boot，做成微服务，只暴露接口。接口设计风格为restful的风格，在get请求下，后台接收参数的注解为RequestBody时会报错；在post请求下，后台接收参数的注解为RequestParam时也会报错。

二、问题原因

     由于spring的RequestParam注解接收的参数是来自于requestHeader中，即请求头，也就是在url中，格式为xxx?username=123&password=456，而RequestBody注解接收的参数则是来自于requestBody中，即请求体中。

三、解决方法

      因此综上所述，如果为get请求时，后台接收参数的注解应该为RequestParam，如果为post请求时，则后台接收参数的注解就是为RequestBody。附上两个例子，截图如下：
---------------------




### 使用Spring自定义注解

1. 自定义一个注解

   ```java
   @Target({ElementType.PARAMETER})
   @Retention(RetentionPolicy.RUNTIME)
   @Documented
   public @interface TokenToUser {
   
       /**
        * 当前用户在request中的名字
        *
        * @return
        */
       String value() default "user";
   
   }
   ```

2. 定义一个相应的拦截器

   spring为我们提供了org.springframework.web.servlet.handler.HandlerInterceptorAdapter这个适配器，继承此类，可以非常方便的实现自己的拦截器。可以根据我们的需要重写preHandle、postHandle、afterCompletio方法。分别实现预处理、后处理（调用了Service并返回ModelAndView，但未进行页面渲染）、返回处理（已经渲染了页面） 
   　　　　在preHandle中，可以进行编码、安全控制等处理； 
   　　　　在postHandle中，有机会修改ModelAndView； 
   　　　　在afterCompletion中，可以根据ex是否为null判断是否发生了异常，进行日志记录。

3. 在Controller中使用

#### Spring自定义参数解析器

自定义解析器需要实现HandlerMethodArgumentResolver接口，HandlerMethodArgumentResolver接口包含两个接口：

- supportsParameter：用于判定是否需要处理该参数分解，返回true为需要，并会去调用下面的方法resolveArgument。

- resolveArgument：真正用于处理参数分解的方法，返回的Object就是controller方法上的形参对象

  1. 自定义注解，若不想自定义注解，可以直接在实现HandlerMethodArgumentResolver的supportsParameter直接返回true

     ```java
     package com.manqian.crm.resolver;
     
     import java.lang.annotation.ElementType;
     import java.lang.annotation.Retention;
     import java.lang.annotation.RetentionPolicy;
     import java.lang.annotation.Target;
     
     
     @Target(ElementType.PARAMETER)
     @Retention(RetentionPolicy.RUNTIME)
     public @interface JsonParam {
     	//三个参数
         String value();
     	//默认为true
         boolean required() default true;
     
         String defaultValue() default "";
     }
     
     ```

  2. 自定义参数解析器，实现HandlerMethodArgumentResolver接口

     ```java
     import com.jayway.jsonpath.JsonPath;
     import com.jayway.jsonpath.PathNotFoundException;
     import com.manqian.crm.api.exception.ParamCheckException;
     import org.apache.commons.io.IOUtils;
     import org.springframework.context.annotation.Configuration;
     import org.springframework.core.MethodParameter;
     import org.springframework.web.bind.support.WebDataBinderFactory;
     import org.springframework.web.context.request.NativeWebRequest;
     import org.springframework.web.method.support.HandlerMethodArgumentResolver;
     import org.springframework.web.method.support.ModelAndViewContainer;
     
     import javax.servlet.http.HttpServletRequest;
     import java.io.IOException;
     
     public class JsonPathArgumentResolver implements HandlerMethodArgumentResolver {
     
         private static final String JSON_REQUEST_BODY = "JSON_REQUEST_BODY";
     
         //判断是否支持要转换的参数类型
         @Override
         public boolean supportsParameter(MethodParameter parameter) {
             return parameter.hasParameterAnnotation(JsonParam.class);//判断是不是相对于的注解
         }
     
         //当支持后进行相应的转换
         @Override
         public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception {
             String body = getRequestBody(webRequest);
             Object val = null;
     
             try {
                 val = JsonPath.read(body, parameter.getParameterAnnotation(JsonParam.class).value());
                 //若注解中声明参数必须且此时参数为空,则抛出异常
                 if (parameter.getParameterAnnotation(JsonParam.class).required() && val == null) {
                     throw new ParamCheckException(parameter.getParameterAnnotation(JsonParam.class).value() + "不能为空");
                 }
             } catch (PathNotFoundException exception) {
                 System.out.println(exception.getStackTrace());
                 if (parameter.getParameterAnnotation(JsonParam.class).required()) {
     //                throw new ParamCheckException(parameter.getParameterAnnotation(JsonParam.class).value() + "不能为空");
                     throw exception;
                 }
             }
             return val;//返回形参对象
         }
     	//获取请求体
         private String getRequestBody(NativeWebRequest webRequest) {
             HttpServletRequest servletRequest = webRequest.getNativeRequest(HttpServletRequest.class);
             //获取JSON请求体
             String jsonBody = (String) servletRequest.getAttribute(JSON_REQUEST_BODY);
             //若请求体为空
             if (jsonBody == null) {
                 try {
                     jsonBody = IOUtils.toString(servletRequest.getInputStream());
                     servletRequest.setAttribute(JSON_REQUEST_BODY, jsonBody);
                 } catch (IOException e) {
                     throw new RuntimeException(e);
                 }
             }
             return jsonBody;
     
         }
     
     }
     
     ```

     3.注册自定义参数解析器

     传统XML格式:

     ```xml
     <mvc:annotation-driven>
           <mvc:argument-resolvers>
             <bean class="com.manqian.crm.resolver.JsonPathArgumentResolver"/>
           </mvc:argument-resolvers>
     </mvc:annotation-driven>
     
     ```

#### SpringMVC的Json转换器

```xml
<mvc:message-converters register-defaults="true">
    <bean class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
        <property name="supportedMediaTypes">
            <list>
                <value>application/json; charset=UTF-8</value>
            </list>
        </property>
        <property name="prettyPrint" value="true"/>
        <property name="objectMapper" ref="objectMapper"/>
    </bean>
</mvc:message-converters>
```

### 易错点

mysql默认端口为3306

文件上传需要配置好sprinmvc的multipartResolver,并设置默认编码以及文件上传的最大值





### 需要解决的事情

- **关于数据库的外键各个关键词的含义**
- 关于final等关键词的含义
- 
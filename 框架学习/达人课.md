[TOC]



## 登陆设计

###  前端:

#### 进行参数校验

```js
/**
 * 判空
 *
 * @param obj
 * @returns {boolean}
 */
function isNull(obj) {
    if (obj == null || obj == undefined || obj.trim() == "") {
        return true;
    }
    return false;
}

/**
 * 参数长度验证
 *
 * @param obj
 * @param length
 * @returns {boolean}
 */
function validLength(obj, length) {
    if (obj.trim().length < length) {
        return true;
    }
    return false;
}

/**
 * 用户名称验证 4到16位（字母，数字，下划线，减号）
 *
 * @param userName
 * @returns {boolean}
 */
function validUserName(userName) {
    var pattern = /^[a-zA-Z0-9_-]{4,16}$/;
    if (pattern.test(userName.trim())) {
        return (true);
    } else {
        return (false);
    }
}

/**
 * 用户密码验证 最少6位，最多20位字母或数字的组合
 *
 * @param password
 * @returns {boolean}
 */
function validPassword(password) {
    var pattern = /^[a-zA-Z0-9]{6,20}$/;
    if (pattern.test(password.trim())) {
        return (true);
    } else {
        return (false);
    }
}
```



ajax异步请求:

```javascript
    var userName = $("#userName").val();
    var password = $("#password").val();
    var data = {"userName": userName, "password": password}
    $.ajax({
        type: "POST",//方法类型
        dataType: "json",//预期服务器返回的数据类型
        url: "users/login",
        contentType: "application/json; charset=utf-8",
        data: JSON.stringify(data),
        success: function (result) {
        }
    });
```

保存Token并跳转页面

```javascript
setCookie("token", result.data.userToken);
alert("登录成功");
window.location.href = "/";
```

```javascript
/**
 * 写入cookie
 *
 * @param name
 * @param value
 */
function setCookie(name, value) {
    var Days = 30; //cookie有效时间
    var exp = new Date(); // cookie生成时间
    exp.setTime(exp.getTime() + Days * 24 * 60 * 60 * 1000);
    document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString() + ";path=/";
 
}
```

### 后台

数据库设计需要有Token值字段(varchar(50)),is_deleted(tinyint(4))

业务层中,在调用了dao操作获取AdminUser时,若获取的AdminUser不为空(即获取的),则生成新的Token值,对数据库中相应的用户进行数据更新

控制层 首先对参数进行验空校验,之后调用Service层对用户对象进行查询,若成功,则调用ResultGenerator生成成功的Result并且将User数据封装在其中,发送回前端.



后台编写注解切面来校验Token值

自定义TokenToUser注解

```java
# TokenToUser.java

@Target({ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface TokenToUser {

    /**
     * 当前用户在request中的名字
     *
     * @return
     */
    String value() default "user";

}
```







## 分页

制作一个分页需要:

前端:进行数据渲染和分页信息展示

数据展示区 :展示数据信息

分页信息区:总页数 页码展示 当前页码 每页条数

后台:需要按照前端传输过来的请求将分页所需要的数据正确的查询并且封装返回

后台需要的两个参数: 页码(需要查询第几页)  每页条数(每次查询多少条数据)

数据库语句为**select * from tb_xxx limit 10,20**

后台还需要将数据总量封装到结果中返回给前端



### 流程

1. 前端将页码和条数两个参数通过 HTTP 请求传输给后端；
2. 后端获取到这两个参数后进行参数验证，查询后将当前页的所有数据实体和数据总量封装；
3. 后端将封装数据返回给前端；
4. 前端获取到数据和数据量后分别进行当前页数据进行渲染和展示，同时完成分页信息区的计算和展示。

### 使用JqGrid制作分页功能

JQGrid是一个在jquery基础上做的一个表格控件，以ajax的方式和服务器端通信。

#### 前端

- JqGrid所需依赖

```html
<link href="plugins/jqgrid-5.3.0/ui.jqgrid-bootstrap4.css" rel="stylesheet"/>
<!-- JqGrid依赖jquery，因此需要先引入jquery.min.js文件 -->
<script src="plugins/jquery/jquery.min.js"></script>

<script src="plugins/jqgrid-5.3.0/grid.locale-cn.js"></script>
<script src="plugins/jqgrid-5.3.0/jquery.jqGrid.min.js"></script>
```



- 分页信息区

  ```html
  <!-- JqGrid必要DOM,用于创建表格展示列表数据 -->  
  <table id="jqGrid" class="table table-bordered"></table>
  <!-- JqGrid必要DOM,分页信息区域 --> 
  <div id="jqGridPager"></div>  
  ```

- 数据交互

  在js文件中完成

  ```javascript
  $("#jqGrid").jqGrid({
          //请求后台 JSON 数据的 URL
          url: 'users/list',   
          //后台返回的数据格式
          datatype: "json",   
          //列表信息，包括表头、宽度、是否显示、渲染参数等属性
      	//name 列显示的名称；index 传到服务器端用来排序用的列名称；width 列宽度；align 对齐方式；sortable 是否可以排序
          colModel: [          
              {label: 'id', name: 'id', index: 'id', width: 50, hidden: true, key: true},
              {label: '登录名', name: 'userName', index: 'userName', sortable: false, width: 80},
              {label: '添加时间', name: 'createTime', index: 'createTime', sortable: false, width: 80}
          ],
          //表格高度，可自行调节
          height: 485,
          //默认一页显示多少条数据，可自行调节
          rowNum: 10,
          //翻页控制条中，每页显示记录数可选集合
          rowList: [10, 30, 50],
          //主题，这里选用的是 Bootstrap 主题
          styleUI: 'Bootstrap',
          //数据加载时显示的提示信息
          loadtext: '信息读取中...',
          //是否显示行号，默认值是 false，不显示
          rownumbers: true,
          //行号列的宽度
          rownumWidth: 35,
          //宽度是否自适应
          autowidth: true,
          //是否可以多选
          multiselect: true,
          //分页信息 DOM
          pager: "#jqGridPager",
          jsonReader: {
              root: "data.list",           //数据列表模型
              page: "data.currPage",       //数据页码
              total: "data.totalPage",     //数据总页码
              records: "data.totalCount"   //数据总记录数
          },
          // 向后台请求的参数
          prmNames: {
              page: "page",
              rows: "limit",
              order: "order"
          },
          // 数据加载完成并且 DOM 创建完毕之后的回调函数
          gridComplete: function () {
              //隐藏 Grid 底部滚动条
              $("#jqGrid").closest(".ui-jqgrid-bdiv").css({"overflow-x": "hidden"});
          }
      });
  ```



  #### 后台

jsonReader 对象定义了如何对后端返回的 JSON 数据进行解析，比如数据列表为何读取 `data.list`，当前页码为何读取 `data.currPage`，这些都是由后端返回的数据格式所决定的，后端响应结果的数据格式定义在 `Result.java` 类中.

  ```java
  public class Result<T> implements Serializable {
      //响应码 200为成功
      private int resultCode;
      //响应msg
      private String message;
      //返回数据,封装数据
      private T data;
  }
  ```

  所有的数据会封装在data属性内

  ```java
  //分页结果集
  public class PageResult implements Serializable {
      //总记录数
      private int totalCount;
      //每页记录数
      private int pageSize;
      //总页数
      private int totalPage;
      //当前页数
      private int currPage;
      //列表数据
      private List<?> list;
  }
  ```



  数据库语句:

  ```sql
    <!-- 查询用户列表 -->
      <select id="findAdminUsers" parameterType="Map" resultMap="AdminUserResult">
          select id,user_name,create_time from tb_admin_user
          where is_deleted=0 <!-- 限定为未删除的用户--!>
          order by id desc	<!-- 按照id进行排列 --!>
          <if test="start!=null and limit!=null">
              limit #{start},#{limit}
          </if>
      </select>
  
      <!-- 查询用户总数 -->
      <select id="getTotalAdminUser" parameterType="Map" resultType="int">
          select count(*) from tb_admin_user
          where is_deleted=0
      </select>
  ```



  业务层:

  调用dao层查询获得List集合数据,int型total用户总数,然后将两个数据封装到PageResult中.

  控制层:

  首先检查前端传进来的page参数(页码),limit(每页条数)是否为空,然后调用业务层进行查询数据,最后将其返回给前台



  ## 弹框

  弹框一般可以用于新增,修改操作

  主要使用场景:

  - 提示框：这是最为常用的方式，对用户进行信息提示。
  - 侧边栏：左侧通常为菜单栏，部分系统会在右侧设计工具栏，弹窗设计也会用到。
  - 选择器：日期选择框、多选框等等页面元素也会用到弹框设计。
  - 扩展信息展示：页面大小有限，部分数据无法全部显示，可以使用弹窗设计进行优化。
  - 信息编辑框：这种方式是另外一个常用的弹框设计，数据的添加和编辑操作被放到弹框中，而不是多次跳转页面。



  ### 弹框技术

  #### BootStrap Modal 模态框

  使用模态窗口，通常需要某种触发器来触发 Modal 事件，比如页面中的添加或者编辑功能，想要信息输入框出现，一定要先点击“添加”或者“编辑”按钮，按钮的实现可以通过 button 或者 `<a>` 标签。下面演示的 Demo 中，我们使用的就是按钮来触发事件。



  ```html
          <button class="btn btn-primary btn-lg" data-toggle="modal" data-target="#myModal">
              直接创建模态框
          </button>
          <button class="btn btn-primary btn-lg" onclick="jsOpenModal()">
              JS 打开模态框
          </button>
          <!-- 模态框（Modal） -->
          <div class="modal fade" id="myModal" tabindex="-1" role="dialog" aria-labelledby="myModalLabel"
               aria-hidden="true">
              <div class="modal-dialog">
                  <div class="modal-content">
                      <div class="modal-header">
                          <button type="button" class="close" data-dismiss="modal" aria-hidden="true">
                              &times;
                          </button>
                          <h4 class="modal-title" id="myModalLabel">
                              模态框（Modal）标题
                          </h4>
                      </div>
                      <div class="modal-body">
                          在这里添加一些文本
                      </div>
                      <div class="modal-footer">
                          <button type="button" class="btn btn-default" data-dismiss="modal">关闭
                          </button>
                          <button type="button" class="btn btn-primary">
                              提交更改
                          </button>
                      </div>
                  </div><!-- /.modal-content -->
              </div><!-- /.modal -->
          </div>
  ```





  ##### Modal 方法

  - show：手动打开模态框。

  ```javascript
  $('#myModal').modal('show');
  ```

  - hide：手动隐藏模态框。

  ```javascript
  $('#myModal').modal('hide');
  ```

  - toggle：切换弹框的可见状态。

  ```javascript
  $('#myModal').modal('toggle');
  ```

#### Custombox 

一个弹窗插件，使用 Javascript 和 CSS 3 实现，配置简单，动画效果丰富，兼容多种终端

##### 可使用参数

```javascript
new Custombox.modal({
  content = {
    target: null, //打开哪个弹框
    effect: 'fadein', //动画效果，效果很多可自行选择想要使用的 fadein为渐变
    id: null, //id
    close: true, // 是否允许使用esc键关闭弹窗 默认true
    animateFrom: 'top', // 动画出现位置 top、left、center、right
    animateTo: 'top', //动画消失位置 top、left、center、right
    positionX: 'center', //横坐标位置 top、left、center、right
    positionY: 'center', //纵坐标位置 top、left、center、right
    width: null, //宽度
    speedIn: 300, //进入速度，以毫秒为单位
    speedOut: 300, //消失速度，以毫秒为单位
    delay: 150, //动画延迟，以毫秒为单位
    fullscreen: false, //设置全屏模式，默认false
    onOpen: null, //钩子函数,弹窗打开时触发
    onComplete: null, //钩子函数,弹窗加载完成时触发
    onClose: null, //钩子函数,弹窗关闭时触发
  }
});
```



onOpen 、onComplete、onClose，分别定义了弹窗打开时触发事件、弹窗加载完成时触发事件、弹窗关闭时触发事件，如果弹框交互复杂，这三个钩子函数可以帮上大忙。

##### 用法

```html
<!-- 弹框触发按钮 -->
<button class="btn btn-primary btn-lg" onclick="custombox1()">
            打开custombox1
</button>

<!-- 定义了一个modal框 -->
<div class="content" id="custombox1" style="display: none">
        <div class="modal-dialog" role="document">
            <div class="modal-content" style="width: 400px;height: 420px;">
                <div class="modal-header">
                    <h6 class="modal-title" id="custombox1Label">custombox1</h6>
                </div>
                <div class="modal-body">
                    <form>
                        <div class="form-group">
                            <div class="alert alert-danger">点击空白处退出</div>
                        </div>
                        <div class="form-group">
                            <div class="alert">这是custombox1！</div>
                        </div>
                    </form>
                </div>
            </div>
        </div>
        <!-- /.content -->
    </div>
```

然后定义按钮触发的弹框事件:

```javascript
function custombox1(){
    var custombox1 = new custombox.modal({
       content:{
			effect:'fadein'
           	target:'custombox1'
       } 
    });
    custombox1.open();
}
```

这样使用按钮就会触发显示弹框

##### 方法

- open()
- close()
- closeAll()

##### 事件

Custombox 初始化时定义的钩子函数，这些钩子函数定义了对应的监听事件，分别是弹框打开触发事件 `onOpen:function(){}`，弹框加载完成触发事件 `onComplete:function(){}`和弹框关闭触发事件 `onClose:function(){}`，演示代码如下。

```javascript
var custombox3 = new Custombox.modal({
            content: {
                effect: 'rotate',
                target: '#custombox3',
                onOpen: function () {
                    alert("custombox3 open事件！")
                },
                onComplete: function () {
                    alert("custombox3 complete事件！")
                },
                onClose: function () {
                    alert("custombox3 close事件！")
                }
            }
        });
custombox3.open();
```





## 图片上传

使用SpringMVC完成图片上传

- 图片上传功能离不开MutipartResolver的设置,他是一个SpringMVC实现文件上传的工具类,在配置了具体的实现类之后, DispatcherServlet 在处理请求时会调用 `MultipartResolver `中的方法判断此请求是不是文件上传请求,如果是,DispatcherServlet会调用MultipartResolver中的`resolveMultipart(request)` 方法对该请求对象进行装饰并返回一个新的 MultipartHttpServletRequest 供后继处理流程使用,此时的HttpServletRequest会转化成MultipartHttpServletRequest类型,此类包括了已经上传的文件对象.

- 时序图如下

  ![](https://images.gitbook.cn/08596b00-9f09-11e8-991f-1fa5582600fd)

- 如上图所示，当收到请求时，DispatcherServlet 的 `checkMultipart()` 方法会调用 MultipartResolver 的 `isMultipart()` 方法判断请求中是否包含文件。

  如果请求数据中包含文件，则调用 MultipartResolver 的 `resolveMultipart()` 方法对请求的数据进行解析，然后将文件数据解析成 MultipartFile 并封装在 MultipartHttpServletRequest（继承了 HttpServletRequest）对象中，最后传递给 Controller 控制器，

- 平时开发的时候 一般会选用MultipartResolver 是 CommonsMultipartResolver

### 实现

- maven导入依赖

  ```xml
   <!-- Start: commons相关依赖包 -->
          <dependency>
              <groupId>commons-io</groupId>
              <artifactId>commons-io</artifactId>
              <version>${commons-io.version}</version>
          </dependency>
          <dependency>
              <groupId>commons-fileupload</groupId>
              <artifactId>commons-fileupload</artifactId>
              <version>${commons-fileupload.version}</version>
          </dependency>
  <!-- end: commons相关依赖包 -->
  ```


- 配置springmvc设置:

  在springmvc.xml进行配置

  ```xml
      <bean id="multipartResolver"  class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
      <!-- 设定默认编码 -->
      <property name="defaultEncoding" value="UTF-8"></property>
      <!-- 设定文件上传的最大值为5MB，5*1024*1024 -->
      <property name="maxUploadSize" value="5242880"></property>
      </bean>
  ```

- ##### LoadImageController

  文件对象已经被封装在MultipartFile对象中,在代码中需要调用此文件对象

  ```java
  public Result upload(HttpServletRequest request, @RequestParam("file") MultipartFile file) throws IOException {
          ServletContext sc = request.getSession().getServletContext();
          String dir = sc.getRealPath("/upload");
          String type = file.getOriginalFilename().substring(file.getOriginalFilename().lastIndexOf(".") + 1, file.getOriginalFilename().length());
          SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
          Random r = new Random();
          String imgName = "";
          if ("jpg".equals(type)) {
              imgName = sdf.format(new Date()) + r.nextInt(100) + ".jpg";
          } else if ("png".equals(type)) {
              imgName = sdf.format(new Date()) + r.nextInt(100) + ".png";
          } else if ("jpeg".equals(type)) {
              imgName = sdf.format(new Date()) + r.nextInt(100) + ".jpeg";
          } else if ("gif".equals(type)) {
              imgName = sdf.format(new Date()) + r.nextInt(100) + ".gif";
          } else {
              return null;
          }
              //将文件流写入到磁盘中
          FileUtils.writeByteArrayToFile(new File(dir, imgName), file.getBytes());
          //返回文件路径
          return Result.ok().put("url", "/upload/" + imgName);
  ```


#### 前端上传工具

使用了Jquery的ajaxupload工具

- 先导入依赖文件

  ```html
  <!-- ajax upload -->
  <script src="plugins/ajaxupload/ajaxupload.js"></script>
  ```

- 设置上传文件的DOM对象

  ```html
      <div class="col-sm-10">
             <a class="btn btn-info" id="upload"><i class="fa fa-picture-o"></i> 上传文件</a>
       </div>
  ```

- 上传前端代码逻辑

  ```javascript
   new AjaxUpload('#upload', {
          action: 'images',//上传地址
          name: 'file',//文件域名字
          autoSubmit: true,
          responseType: "json",
       //上传之前的操作
          onSubmit: function (file, extension) {
              if (!(extension && /^(jpg|jpeg|png|gif)$/.test(extension.toLowerCase()))) {
                  alert('只支持jpg、png、gif格式的图片！', {
                      icon: "error",
                  });
                  return false;
              }
          },
          onComplete: function (file, r) {
              if (r.resultCode == 200) {
                  alert("上传成功");
                  $("#picturePath").val(r.data);
                  $("#img").attr("src", r.data);
                  $("#img").attr("style", "width: 100px;height: 100px;display:block;");
                  return false;
              } else {
                  alert(r.message);
              }
          }
      });
  ```




## 多文件上传以及其他

### WebUploader

- 定义样式:

  ```html
  <div id="uploader-demo">
     <div>
     <div id="fileUploader">选择图片</div>
     <button id="upload" class="btn btn-default">开始上传</buttton>
     </div>
  </div>
  ```

- 导入依赖文件

  ```html
  <script src="plugins/webuploader/webuploader.min.js"></script>
  <link href="plugins/webuploader/webuploader.css" rel="stylesheet"/>
  ```

- 初始化WebUploader

  ```javascript
          var thumbnailWidth = 0.5;   //缩略图高度和宽度，当宽高度是0~1的时候，按照百分比计算
          var thumbnailHeight = 0.5;
          var uploader = WebUploader.create({
              auto: false,// 选完文件后，是否自动上传
              swf: 'plugins/webupload/Uploader.swf',// swf文件路径
              server: '/images',// 文件接收服务端url
              method: 'POST',// 服务端请求方法
              pick: '#fileUploader',// 选择文件的按钮
              fileNumLimit: 10,//文件总数量只能选择10个,多于10个部分不会加入上传队列
              fileSizeLimit: 100 * 1024 * 1024,//验证文件总大小是否超出限制, 超出则不允许加入队列 100M
              fileSingleSizeLimit: 4 * 1024 * 1024,//验证单个文件大小是否超出限制, 超出则不允许加入队列 4M
              compress: false,//配置压缩的图片的选项。如果此选项为false, 则图片在上传前不进行压缩。
              threads: 4,//上传并发数,允许同时最大上传进程数,默认值为3
              accept: {//指定接受哪些类型的文件
                  title: 'Images',
                  extensions: 'gif,jpg,jpeg,bmp,png',// 只允许选择部分图片格式文件，可自行修改
                  mimeTypes: 'image/*'
              },
          });
  ```

  同时注册上传事件:

  ```javascript
  $("#upload").click(function () {
                  $("#imgResult").html('');
                  //文件处理时增加了alert事件,不需要的话自行删除即可
                  alert("开始上传");
                  uploader.upload();
                  alert("上传完成");
              }
          )
  ```





多文件上传在后台层面和单文件上传并无区别,原因是因为多文件上传使用的是多次上传单个文件,因此控制器相同.

### 大文件

需要使用分片上传的功能

- 前端实现

  初始化WebUploader与前面不同的地方在于增加了分片上传的参数:chunked、chunkSize。同时 fileSizeLimit 和 fileSingleSizeLimit 两个文件大小限制的参数也相应做了调整。

  ```js
  var uploader = WebUploader.create({
              auto: false,// 选完文件后，是否自动上传
              swf: 'plugins/webupload/Uploader.swf',// swf文件路径
              server: '/upload/files',// 文件接收服务端url
              method: 'POST',// 服务端请求方法
              pick: '#picker',// 选择文件的按钮
              fileNumLimit: 10,//文件总数量只能选择10个,多于10个部分不会
              compress: false,//配置压缩的图片的选项。如果此选项为false, 则图片在上传前不进行压缩。
              chunked: true, //开启分块上传
              chunkSize: 5 * 1024 * 1024,//分片大小 默认5M
              chunkRetry: 3,//网络问题上传失败后重试次数
              threads: 1, //上传并发数 大文件时建议设置为1
              fileSizeLimit: 2000 * 1024 * 1024,//验证文件总大小是否超出限制, 超出则不允许加入队列 最大2000M
              fileSingleSizeLimit: 2000 * 1024 * 1024//验证单个文件大小是否超出限制, 超出则不允许加入队列  最大2000M
              //为了大文件处理就没有设置文件类型限制,可根据业务需求进行设置
              // accept: {//指定接受哪些类型的文件
              //     title: 'Images',
              //     extensions: 'gif,jpg,jpeg,bmp,png',// 只允许选择部分图片格式文件。
              //     mimeTypes: 'image/*'
              // },
          });
  ```

  注册uploadBeforeSend事件,对文件上传之前进行切割和参数填充.


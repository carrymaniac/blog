# 数据库事务



## ACID

- 原子性:

  整个事务的全部操作,要么全部完成,要么全部不完成;如果在执行过程中发生错误,会被回滚到事务开始前的状态

- 一致性

  事务必须保证系统处于一个一致的状态,不管在任意给定的时间并发事务有多少

- 持久性

  事务完成之后,事务对数据库的操作更改便永久留在数据库中

- 隔离性

  指两个事务之间的隔离程度

## 隔离级别

### Read uncommitted (读未提交)

​	脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。

​	最低隔离级别;允许一个事务去读取另一个事务未提交的数据

##### 脏读示例：

在事务A和事务B同时执行时可能会出现如下场景：

| 时间 | 事务A（存款）          | 事务B（取款）              |
| ---- | ---------------------- | -------------------------- |
| T1   | 开始事务               | ——                         |
| T2   | ——                     | 开始事务                   |
| T3   | ——                     | 查询余额（1000元）         |
| T4   | ——                     | 取出1000元（余额0元）      |
| T5   | 查询余额（0元）        | ——                         |
| T6   | ——                     | 撤销事务（余额恢复1000元） |
| T7   | 存入500元（余额500元） | ——                         |
| T8   | 提交事务               | ——                         |

余额应该为1500元才对。请看T5时间点，事务A此时查询的余额为0，这个数据就是**脏数据**，他是事务B造成的，很明显是事务没有进行隔离造成的。

### 读写提交(read/commit)

​	为了克服脏读提出的第二个隔离级别;提出了读已提交,读写提交是不同的时候执行的时候只能获取到已经提交的数据。但存在第二个问题:**不可重复读**

​	不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。

　　例如事务T1在读取某一数据，而事务T2立马修改了这个数据并且提交事务给数据库，事务T1再次读取该数据就得到了不同的结果，发送了不可重复读。

　　不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。

#### 不可重复读示例

可是解决了脏读问题，但是还是解决不了可重复读问题。

| 时间 | 事务A（存款）      | 事务B（取款）         |
| ---- | ------------------ | --------------------- |
| T1   | 开始事务           | ——                    |
| T2   | ——                 | 开始事务              |
| T3   | ——                 | 查询余额（1000元）    |
| T4   | 查询余额（1000元） | ——                    |
| T5   | ——                 | 取出1000元（余额0元） |
| T6   | ——                 | 提交事务              |
| T7   | 查询余额（0元）    | ——                    |
| T8   | 提交事务           | ——                    |

事务A其实除了查询两次以外，其它什么事情都没做，结果钱就从1000编程0了，这就是不可重复读的问题。

### 可重复读(repeatable read)

​	为了克服不可重复读而提出的一个隔离级别;可重复读就是保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的。因此该事务级别进制了不可重复读取和脏读，但是有可能出现幻读的数据。

​	但产生了新的问题:幻读

#### 幻读

幻读就是指同样的事务操作，在前后两个时间段内执行对同一个数据项的读取，可能出现不一致的结果。

| 时间 | 事务A（统计总存款）  | 事务B（存款） |
| ---- | -------------------- | ------------- |
| T1   | 开始事务             | ——            |
| T2   | ——                   | 开始事务      |
| T3   | 统计总存款（1000元） | ——            |
| T4   | ——                   | 存入100元     |
| T5   | ——                   | 提交事务      |
| T6   | 提交总存款（10100）  | ——            |
| T7   | 提交事务             | ——            |

银行工作人员在一个事务中多次统计总存款时看到结果不一样。如果要解决幻读，那只能使用顺序读了。

### 顺序读(Serializable)

顺序读是最严格的事务隔离级别。它要求所有的事务排队顺序执行，即事务只能一个接一个地处理，不能并发。

## 事务隔离级别对比

| 事务隔离级别                 | 脏    读 | 不可重复读 | 幻    读 |
| ---------------------------- | -------- | ---------- | -------- |
| 读未提及（READ_UNCOMMITTED） | 允许     | 允许       | 允许     |
| 读已提交（READ_COMMITTED）   | 禁止     | 允许       | 允许     |
| 可重复读（REPEATABLE_READ）  | 禁止     | 禁止       | 允许     |
| 顺序读（SERIALIZABLE）       | 禁止     | 禁止       | 禁止     |


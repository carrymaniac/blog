# 面试题答案

[TOC]

## JAVA基础

### 实例方法和静态方法有什么不一样?

从调用方法来说：

概念分析：静态方法是在类中用static修饰的方法，在类定义的时候就已经被装载和分配

而实例方法只有在被调用的时候才会被分配内存。

访问范围：静态方法只能访问静态成员

### Java中的异常有哪几类?分别怎么使用?

![page16image66914752.png](/Users/carrymaniac/Library/Application Support/typora-user-images/page16image66914752.png) 

​	在 Java 中，所有的异常都有一个共同的祖先java.lang包中的 Throwable类。Throwable: 有两个重要的子类:Exception(异常) 和 Error(错误) ，二者都是 Java 异常处理的重要子类，各自都包含大量子类。

​	**Error**是虚拟机无法处理的错误，比如常见的OOM和NoClassDefFoundError；这些错误是不可查的，因为它们在应用程序的控制和 处理能力之 外，而且绝大多数是程序运行时不允许出现的状况。

​	**Exception**(异常):是程序本身可以处理的异常。Exception 类有一个重要的子类 RuntimeException。RuntimeException 异常由Java虚拟机抛出。

​	注意:异常和错误的区别:异常能被程序本身可以处理，错误是无法处理。

Throwable类常用方法

- public string getMessage():返回异常发生时的详细信息
- public string toString():返回异常发生时的简要描述
- public string getLocalizedMessage():返回异常对象的本地化信息。使用Throwable的子类覆盖这个方法， 可以声称本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与getMessage()返回的结果相同public void printStackTrace():在控制台上打印Throwable对象封装的异常信息

4种情况finally块中语句不返回：

1. 在finally语句块中发生了异常。
2. 在前面的代码中用了System.exit()退出程序。
3. 程序所在的线程死亡。
4. 关闭CPU。

### 内存溢出是怎么回事

即OOM，原因有以下：

- 内存加载的数据过于庞大
- 启动参数设置过小 `-xms128m -xmx128m`
- 集合中有对对象的引用，使用完为清空导致JVM不能回收
- 代码存在死循环



分位置则有：

- 堆溢出**java.lang.OutOfMemoryError: Java heap space**

  当需要为对象实例分配内存，而堆的内存占用又已经达到-Xmx设置的最大值。将会抛出OutOfMemoryError异常

- 永久代溢出**PermGen space溢出： java.lang.OutOfMemoryError: PermGen space**

  APP会载入很多CLASS的话，就很可能出现PermGen space溢出。一般发生在程序的启动阶段。
  解决方法： 通过-XX:PermSize和-XX:MaxPermSize设置永久代大小即可。

- **栈溢出： java.lang.StackOverflowError : Thread Stack space**



### ClassLoader有什么用

ClassLoader根据一个指定的类的全限定名,找到对应的Class字节码文件,然后加载它转化成一个java.lang.Class类的一个实例.

其中有三大类型：

**启动类加载类(Bootstarp ClassLoader)**:用来加载java的核心库,此类加载器并不继承于java.lang.ClassLoader,不能被java程序直接调用,代码是使用C++编写的.是虚拟机自身的一部分.

**扩展类加载器(Extendsion ClassLoader):**用来加载java的扩展库,开发者可以直接使用这个类加载器.

**应用程序类加载器(Application ClassLoader):**:责加载用户类路径(CLASSPATH)下的类库,一般我们编写的java类都是由这个类加载器加载



### ==和equals的区别?

==:判断两个对象的地址是否相同，基本数据类型==比较的是 值，引用数据类型==比较的是内存地址

equals:有两种使用情况:

情况1:类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。 情况2:类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等;若它们的内容相 等，则返回 true (即，认为这两个对象相等)。



### hashCode方法的作用?

用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。

1. 如果两对象equals()是true,那么它们的hashCode()值一定相等
2. 如果两个对象的hashCode相等，他们的equals不一定为true

计算键的hashcode作为存储键信息的数组下标用于查找键对象的存储位置，同时用来键(Key)之间的比较



### Object类中有哪些方法?

```java
public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方 法。
public native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的 HashMap。
public boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户 比较字符串的值是否相等。
public final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视 器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒 在此对象监视器上等待的所有线程，而不是一个线程。
public final native void wait(long timeout) throws InterruptedException//native方法，并且不能 重写。暂停线程的执行。注意:sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
public final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数， 这个参数表示额外时间(以毫微秒为单位，范围是 0-999999)。 所以超时的时间还需要加上nanos毫秒。
public final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等 待，没有超时时间这个概念
public String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方 法。
protected native Object clone() throws CloneNotSupportedException//naitive方法，用于创建并返回 当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生 CloneNotSupportedException异常。
public final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了 final关键字修饰，故不允许子类重写。


```

### NIO是什么?适用于何种场景?

NIO为同步非阻塞IO

同步非阻塞，同步体现在 selector 仍然要去轮循判断 channel 是否准备好，非阻塞体现在这个过程中处理线程不会一直在等待，可以去做其他的事情。

NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。

如果需要管理同时打开的[成千上万](https://www.baidu.com/s?wd=成千上万&tn=24004469_oem_dg&rsv_dl=gh_pl_sl_csd)个连接，这些连接每次只是发送少量的数据，例如聊天服务器，这时候用NIO处理数据可能是个很好的选择。



## JAVA集合

### 常见的集合类有哪些？

![集合框架](/Users/carrymaniac/Desktop/面试知识点图片/集合框架.png)

如何排序：使用Collections.sort并且带入比较器进行比较

其中：小于60：使用插入排序，插入排序是稳定的
大于60的数据量会根据数据类型选择排序方式：
基本类型：使用快速排序。因为基本类型。1、2都是指向同一个常量池不需要考虑稳定性。
Object类型：使用归并排序。因为归并排序具有稳定性。
注意：不管是快速排序还是归并排序。在二分的时候小于60的数据量依旧会使用插入排序



### ArrayList和LinkedList的内部实现

- ArrayList底层为Object数组，而LL为Node双向链表
- AL在指定位置插入删除元素受数据位置影响，近似O(n)、而LL不受影响，复杂度均为O(1)
- LinkedList 不支持高效的随机元素访问，而 ArrayList 支持。快速随机访问就是通 过元素的序号快速获取元素对象(对应于get(int index)方法)。
- 内存空间占用: ArrayList的空间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空 间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间(因为要存放直接后继和直接前驱以及数 据)。



### ArrayList 和 Vector 的区别

Vector是一个同步容器，所有的方法中都加上了Synchronized关键字排他锁。性能比起AL要查，算是线程安全的

Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。

### 快速失败 (fail-fast) 和安全失败 (fail-safe) 的区别是什么？

Iterator的安全失败是基于对底层集合做拷贝，因此，它不受源集合上修改的影响。java.util包下面的所有的集合类都是快速失败的，而java.util.concurrent包下面的所有的类都是安全失败的。快速失败的迭代器会抛出ConcurrentModificationException异常，而安全失败的迭代器永远不会抛出这样的异常。

**fail-fast机制**，是一种错误检测机制。它只能被用来检测错误，因为JDK并不保证fail-fast机制一定会发生**。**若在多线程环境下使用fail-fast机制的集合，建议使用“java.util.concurrent包下的类”去取代“java.util包下的类”。



### hashmap 的数据结构

JDK8以前：数组加上链表

JDK8之后：数组加上链表或红黑树(当链表到达一定长度时进行变化，阀值默认为8)

### HashMap 的工作原理是什么?

- 首先计算Key的hashCode值，由于hashCode共有32位，不可能用这么长的数进行后面的计算，因此需要先进行扰动，为了充分提取hashcode信息，因此在jdk8中，扰动函数为：`return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);` 即将高6位于hashcode进行按位异或操作。
- 通过i=(n-1)&hash值，计算出下标i（即于数据长度n做取余操作）
- 判断i位置在数组中是否有值，没有值的话则初始化将Node放在此处即可
- 若有值，则发生了碰撞
  - 判断该位置的第一个数据和我们要插入的数据是否相同，若相同，则将其取出。
  - 若否，发现该节点是树结构，则调用putTreeVal方法。
  - 如碰撞之后发现是链表，则遍历列表，把节点挂在链表的表尾，若发现链表已经8位，则调用treeifyBin来将其装换为红黑树
  - 若在遍历链表中发现key值相同，则覆盖对于的node的值即可。
  - 将上面的相同节点覆盖value值
- 新增完值之后，判断size是否超过阀值，若超过，则进行扩容，调用resize方法

其中在插入判断是否存在的时候，会先查看两个值是否实现了comparable接口，若实现了则使用类名进行比较，若类名相同则调用hashcode进行比较



### Hashmap 什么时候进行扩容呢？

在1.8中，当完成了插入之后，会检查size是否超过阀值决定是否扩容。



### List、Map、Set 三个接口，存取元素时，各有什么特点？

Set里面不允许有重复的元素，

存元素：add方法有一个boolean的返回值，当集合中没有某个元素，此时add方法可成功加入该元素时，则返回true；当集合含有与某个元素equals相等的元素时，此时add方法无法加入该元素，返回结果为false。

取元素：没法说取第几个，只能以Iterator接口取得所有的元素，再逐一遍历各个元素。



List表示有先后顺序的集合，

存元素：多次调用add(Object)方法时，每次加入的对象按先来后到的顺序排序，也可以插队，即调用add(int index,Object)方法，就可以指定当前对象在集合中的存放位置。

取元素：方法1：Iterator接口取得所有，逐一遍历各个元素

​        方法2：调用get(index i)来明确说明取第几个。



Map是双列的集合，存放用put方法:put(obj key,obj value)，每次存储时，要存储一对key/value，不能存储重复的key，这个重复的规则也是按equals比较相等。

取元素：用get(Object key)方法根据key获得相应的value。

​        也可以获得所有的key的集合，还可以获得所有的value的集合，

​        还可以获得key和value组合成的Map.Entry对象的集合。





### Set 里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用 == 还是 equals()? 它们有何区别?

Set 里的元素是不能重复的，元素重复与否是使用 equals()方法进行判断的。
equals()和==方法决定引用值是否指向同一对象 equals()在类中被覆盖，为的是当两个
分离的对象的内容和类型相配的话，返回真值。



### heap 和 stack 有什么区别。

1.heap是堆，stack是栈。

2.stack的空间由操作系统自动分配和释放，heap的空间是手动申请和释放的，heap常用new关键字来分配。

3.stack空间有限，heap的空间是很大的自由区。在Java中，若只是声明一个对象，则先在栈内存中为其分配地址空间，若再new一下，实例化它，则在堆内存中为其分配地址。



### Java 集合类框架的基本接口有哪些？

总共有两大接口：Collection 和Map ，一个元素集合，一个是键值对集合； 

其中List和Set接口继承了Collection接口，一个是有序元素集合，一个是无序元素集合； 

而ArrayList和 LinkedList 实现了List接口，HashSet实现了Set接口，这几个都比较常用；

HashMap 和HashTable实现了Map接口，并且HashTable是线程安全的，但是HashMap性能更好；



### HashSet 和 TreeSet 有什么区别？

- HashSet：
  不能保证元素的排列顺序，顺序有可能发生变化
  集合元素可以是null,但只能放入一个null(由于底层时HashMap因此这个特性是一致的)
  HashSet底层是采用HashMap实现的
  HashSet底层是哈希表实现的

- TreeSet：
  Treeset中的数据是排好序的，不允许放入null值。
  TreeSet是通过TreeMap实现的,只不过Set用的只是Map的key。
  TreeSet的底层实现是采用二叉树（红-黑树）的数据结构。

### LinkedHashMap 的实现原理?

LinkedHashMap: LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和 链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以 保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。

就是多了一个head和tail串联起所有的节点。其有序性是指放入的顺序。



### 为什么集合类没有实现 Cloneable 和 Serializable 接口？

克隆（cloning）或者序列化（serialization）的语义和含义是跟具体的实现相关的。因此应该由集合类的具体实现类来决定如何被克隆或者序列化



### 数组 (Array) 和列表 (ArrayList) 有什么区别？什么时候应该使用 Array 而不是 ArrayList？

Array：它是数组，申明数组的时候就要初始化并确定长度，长度不可变，而且它只能存储同一类型的数据，比如申明为String类型的数组，那么它只能存储String听类型数据 
ArrayList：它是一个集合，需要先申明，然后再添加数据，长度是根据内容的多少而改变的，ArrayList可以存放不同类型的数据，在存储基本类型数据的时候要使用基本数据类型的包装类



### Comparable 和 Comparator 接口是干什么的？列出它们的区别

- java提供了只包含一个compareTo()方法的Comparable接口。这个方法可以个给两个对象排序。具体来说，它返回负数，0，正数来表明已经存在的对象小于，等于，大于输入对象。
- Java提供了包含compare()和equals()两个方法的Comparator接口。compare()方法用来给两个输入参数排序，返回负数，0，正数表明第一个参数是小于，等于，大于第二个参数。equals()方法需要一个对象作为参数，它用来决定输入参数是否和comparator相等。只有当输入参数也是一个comparator并且输入参数和当前comparator的排序结果是相同的时候，这个方法才返回true。
- Comparable & Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序。



## JAVA并发



### **Synchronized**原理是什么

Synchronized 是由 JVM 实现的一种实现互斥同步的一种方式，被 Synchronized 修饰过的程序块，在编译前后被编译器生成了 `monitorenter` 和 `monitorexit` 两个字节码指令。

在虚拟机执行到 `monitorenter` 指令时，首先要尝试获取对象的锁，如果这个对象没有锁定，或者当前线程已经拥有了这个对象的锁，把锁的计数器 +1；当执行 `monitorexit` 指令时将锁计数器 -1；当计数器为 0 时，锁就被释放了。如果获取对象失败了，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。

Java 中 Synchronize 通过在对象头设置标记，达到了获取锁和释放锁的目的。

### 对象的锁指的是什么

每个对象都有个 monitor 对象，加锁就是在竞争 monitor 对象，代码块加锁是在前后分别加上 monitorenter 和 monitorexit 指令来实现的，方法加锁是通过一个标记位来判断的。

当一个对象被锁住时，对象里面所有用 Synchronized 修饰的方法都将产生堵塞，而对象里非 Synchronized 修饰的方法可正常被调用，不受锁影响。

### 可重入性



### 锁优化

由于 Java 层面的线程与操作系统的原生线程有映射关系，如果要将一个线程进行阻塞或唤起都需要操作系统的协助，这就需要从用户态切换到内核态来执行，这种切换代价十分昂贵，很耗处理器时间，现代 JDK 中做了大量的优化。

- 无锁
- 偏向锁：
  - 当没有竞争出现时，默认会使用偏向锁。
  - JVM 会利用 CAS 操作，在对象头上的 Mark Word 部分设置线程 ID，以表示这个对象偏向于当前线程，所以并不涉及真正的互斥锁，因为在很多应用场景中，大部分对象生命周期中最多会被一个线程锁定，使用偏斜锁可以降低无竞争开销。
- 轻量级锁
  - 如果有一个线程试图锁定偏斜的对象，则锁进化为轻量级锁
  - 轻量级锁依赖 CAS 操作 Mark Word 来试图获取锁，如果重试成功，就使用普通的轻量级锁；否则，进一步升级为重量级锁。
- 重量级锁

### 非公平锁

非公平主要表现在获取锁的行为上，并非是按照申请锁的时间前后给等待线程分配锁的，每当锁被释放后，任何一个线程都有机会竞争到锁，这样做的目的是为了提高执行性能，缺点是可能会产生线程饥饿现象。



### 锁消除锁粗化

锁消除“JVM判断对不可能产生竞争关系的锁进行消除，主要根据逃逸分析

锁粗化：一系列连续的操作都需要对同一个对象反复加锁和解锁，甚至加锁操作在循环体内，频繁地进行互斥同步操作也会导致不必要的性能损耗。因此将锁的作用领域扩大。

### Synchronized 是一个悲观锁

无论是否会发生竞争，任何数据操作都需要加锁、用户态核心态转换、维护锁的计数器、检查是否需要唤醒线程

### 乐观锁

先进行操作，如果没有其他线程征用数据，那操作就成功了；如果共享数据有征用，产生了冲突，那就再进行其他的补偿措施。这种乐观的并发策略的许多实现不需要线程挂起，**所以被称为非阻塞同步。**

原理为CAS，内存值 预计值 新值 ；首先检查某块内存的值是否跟之前我读取时的一样，如不一样则表示期间此内存值已经被别的线程更改过，舍弃本次操作，否则说明期间没有其他线程对此内存值操作，可以把新值设置给此块内存。

CAS 具有原子性，它的原子性由 CPU 硬件指令实现保证，即使用 JNI 调用 Native 方法调用由 C++ 编写的硬件级别指令，JDK 中提供了 Unsafe 类执行这些操作。



缺点：乐观锁只能维持一个共享变量的原子操作。长期自选可能造成严重的性能损耗。ABA问题



### 跟 Synchronized 相比，可重入锁 ReentrantLock 其实现原理有什么不同？

所有的锁的实现原理目的无外乎为：让线程看见一个标记一标示共享变量的状态

Synchronized 通过在对象头中设置标记实现了这一目的，是一种 JVM 原生的锁实现方式

而 ReentrantLock 以及所有的基于 Lock 接口的实现类，都是通过用一个 volitile 修饰的 int 型变量，并保证每个线程都能拥有对该 int 的可见性和原子修改，其本质是基于所谓的 AQS 框架。



### AQS 框架

- AQS 在内部定义了一个 volatile int state 变量，表示同步状态：当线程调用 lock 方法时 ，如果 state=0，说明没有任何线程占有共享资源的锁，可以获得锁并将 state=1；如果 state=1，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待。

- 底层基于CAS和volatile

- 核心数据结构为一个volatile int state和一个FIFO线程等待队列，其中state表示的是共享资源的数量，如果是互斥访问一般设置为1，如果共享访问设置为N。

- 该双向链表结构的同步队列是通过Node内部类构成的，当有线程获取锁失败后，就被添加到队列末尾。

  

  - Node 类是对要访问同步代码的线程的封装，包含了线程本身及其状态叫 waitStatus（有五种不同 取值，分别表示是否被阻塞，是否等待唤醒，是否已经被取消等），每个 Node 结点关联其 prev 结点和 next 结点，方便线程释放锁后快速唤醒下一个在等待的线程，是一个 FIFO 的过程。

  - ①CANCELLED=1：表示线程因为中断或者等待超时，需要从等待队列中取消等待；

  - 

    

  - Node 类有两个常量，SHARED 和 EXCLUSIVE，分别代表共享模式和独占模式。所谓共享模式是一个锁允许多条线程同时操作（信号量 Semaphore 就是基于 AQS 的共享模式实现的），独占模式是同一个时间段只能有一个线程对共享资源进行操作，多余的请求线程需要排队等待（如 ReentranLock）。

    

- AQS 通过内部类 ConditionObject 构建等待队列（可有多个），当 Condition 调用 wait() 方法后，线程将会加入等待队列中，而当 Condition 调用 signal() 方法后，线程将从等待队列转移动同步队列中进行锁竞争。

- 

